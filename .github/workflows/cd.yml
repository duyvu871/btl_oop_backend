name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types: [completed]
    branches: [main]
  workflow_dispatch:

env:
  IMAGE_NAME: adc300/btl_oop   # repo image tr√™n Docker Hub c·ªßa b·∫°n

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Compute image tags (method #1)
        run: |
          CI_SHA="${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}"
          SHORT_SHA="${CI_SHA::7}"
          echo "IMAGE_LATEST=${{ env.IMAGE_NAME }}:latest" >> $GITHUB_ENV
          echo "IMAGE_SHA=${{ env.IMAGE_NAME }}:sha-${SHORT_SHA}" >> $GITHUB_ENV
          echo "Computed:"
          echo "  IMAGE_LATEST=$IMAGE_LATEST"
          echo "  IMAGE_SHA=$IMAGE_SHA"

      - name: Upload compose to server
        uses: appleboy/scp-action@v1
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: "./docker-compose.prod.yml"
          target: "${{ secrets.DEPLOY_PATH }}/"

      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          # Image vars t√≠nh ·ªü b∆∞·ªõc tr∆∞·ªõc
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_SHA:  ${{ env.IMAGE_SHA }}

          # App vars
          DEBUG: ${{ secrets.DEBUG || 'False' }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}

          # Database
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_SERVER: ${{ secrets.POSTGRES_SERVER || 'postgres' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}

          # Redis
          REDIS_URL:  ${{ secrets.REDIS_URL  || 'redis://redis:6379' }}
          REDIS_HOST: ${{ secrets.REDIS_HOST || 'redis' }}
          REDIS_PORT: ${{ secrets.REDIS_PORT || '6379' }}
          REDIS_DB:   ${{ secrets.REDIS_DB   || '0' }}

          # Qdrant
          QDRANT_URL: ${{ secrets.QDRANT_URL || 'http://qdrant:6333' }}

          # Security / JWT
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          ALGORITHM:  ${{ secrets.ALGORITHM || 'HS256' }}
          ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES || '30' }}

          # Email / SMTP
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          SMTP_TLS: ${{ secrets.SMTP_TLS }}
          EMAILS_FROM_EMAIL: ${{ secrets.EMAILS_FROM_EMAIL }}
          EMAILS_FROM_NAME: ${{ secrets.EMAILS_FROM_NAME }}

          # Sentry
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}

          # ARQ Worker
          ARQ_QUEUE_NAME: ${{ secrets.ARQ_QUEUE_NAME || 'arq:queue' }}
          ARQ_MAX_JOBS:   ${{ secrets.ARQ_MAX_JOBS   || '10' }}
          ARQ_JOB_TIMEOUT: ${{ secrets.ARQ_JOB_TIMEOUT || '300' }}

          # Superuser
          FIRST_SUPERUSER:          ${{ secrets.FIRST_SUPERUSER }}
          FIRST_SUPERUSER_PASSWORD: ${{ secrets.FIRST_SUPERUSER_PASSWORD }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT != '' && secrets.SSH_PORT || '22' }}
          envs: IMAGE_NAME,IMAGE_SHA,DEBUG,FRONTEND_URL,POSTGRES_USER,POSTGRES_PASSWORD,POSTGRES_SERVER,POSTGRES_DB,REDIS_URL,REDIS_HOST,REDIS_PORT,REDIS_DB,QDRANT_URL,SECRET_KEY,ALGORITHM,ACCESS_TOKEN_EXPIRE_MINUTES,SMTP_HOST,SMTP_PORT,SMTP_USER,SMTP_PASSWORD,SMTP_FROM,SMTP_TLS,EMAILS_FROM_EMAIL,EMAILS_FROM_NAME,SENTRY_DSN,ARQ_QUEUE_NAME,ARQ_MAX_JOBS,ARQ_JOB_TIMEOUT,FIRST_SUPERUSER,FIRST_SUPERUSER_PASSWORD
          script: |
            set -euo pipefail

            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            mkdir -p "$DEPLOY_PATH"
            cd "$DEPLOY_PATH"
            
            echo "üìÇ Current directory: $(pwd)"
            
            # N·∫øu server c·∫ßn sudo cho Docker CE, b·∫≠t 3 d√≤ng n√†y v√† prefix 'sudo -E' cho m·ªçi l·ªánh docker:
            # alias docker='sudo -E docker'
            # alias compose='sudo -E docker compose'
            # export DOCKER_HOST=unix:///var/run/docker.sock

            echo "üîê Write .env (chmod 600)"
            # Export all variables so they can be used in heredoc
            export DEBUG="${DEBUG}"
            export FRONTEND_URL="${FRONTEND_URL}"
            export POSTGRES_USER="${POSTGRES_USER}"
            export POSTGRES_PASSWORD="${POSTGRES_PASSWORD}"
            export POSTGRES_SERVER="${POSTGRES_SERVER}"
            export POSTGRES_DB="${POSTGRES_DB}"
            export REDIS_URL="${REDIS_URL}"
            export REDIS_HOST="${REDIS_HOST}"
            export REDIS_PORT="${REDIS_PORT}"
            export REDIS_DB="${REDIS_DB}"
            export QDRANT_URL="${QDRANT_URL}"
            export SECRET_KEY="${SECRET_KEY}"
            export ALGORITHM="${ALGORITHM}"
            export ACCESS_TOKEN_EXPIRE_MINUTES="${ACCESS_TOKEN_EXPIRE_MINUTES}"
            export SMTP_HOST="${SMTP_HOST}"
            export SMTP_PORT="${SMTP_PORT}"
            export SMTP_USER="${SMTP_USER}"
            export SMTP_PASSWORD="${SMTP_PASSWORD}"
            export SMTP_FROM="${SMTP_FROM}"
            export SMTP_TLS="${SMTP_TLS}"
            export EMAILS_FROM_EMAIL="${EMAILS_FROM_EMAIL}"
            export EMAILS_FROM_NAME="${EMAILS_FROM_NAME}"
            export SENTRY_DSN="${SENTRY_DSN}"
            export ARQ_QUEUE_NAME="${ARQ_QUEUE_NAME}"
            export ARQ_MAX_JOBS="${ARQ_MAX_JOBS}"
            export ARQ_JOB_TIMEOUT="${ARQ_JOB_TIMEOUT}"
            export FIRST_SUPERUSER="${FIRST_SUPERUSER}"
            export FIRST_SUPERUSER_PASSWORD="${FIRST_SUPERUSER_PASSWORD}"
            
            cat > .env <<EOF
            DEBUG=${DEBUG}
            FRONTEND_URL=${FRONTEND_URL}
            
            POSTGRES_USER=${POSTGRES_USER}
            POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            POSTGRES_SERVER=${POSTGRES_SERVER}
            POSTGRES_DB=${POSTGRES_DB}
            
            REDIS_URL=${REDIS_URL}
            REDIS_HOST=${REDIS_HOST}
            REDIS_PORT=${REDIS_PORT}
            REDIS_DB=${REDIS_DB}
            
            QDRANT_URL=${QDRANT_URL}
            
            SECRET_KEY=${SECRET_KEY}
            ALGORITHM=${ALGORITHM}
            ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}
            
            SMTP_HOST=${SMTP_HOST}
            SMTP_PORT=${SMTP_PORT}
            SMTP_USER=${SMTP_USER}
            SMTP_PASSWORD=${SMTP_PASSWORD}
            SMTP_FROM=${SMTP_FROM}
            SMTP_TLS=${SMTP_TLS}
            EMAILS_FROM_EMAIL=${EMAILS_FROM_EMAIL}
            EMAILS_FROM_NAME=${EMAILS_FROM_NAME}
            
            SENTRY_DSN=${SENTRY_DSN}
            
            ARQ_QUEUE_NAME=${ARQ_QUEUE_NAME}
            ARQ_MAX_JOBS=${ARQ_MAX_JOBS}
            ARQ_JOB_TIMEOUT=${ARQ_JOB_TIMEOUT}
            
            FIRST_SUPERUSER=${FIRST_SUPERUSER}
            FIRST_SUPERUSER_PASSWORD=${FIRST_SUPERUSER_PASSWORD}
            EOF
            chmod 600 .env
            
            echo "‚úÖ .env file created. Validating critical vars..."
            if grep -q "SECRET_KEY=" .env && grep -q "POSTGRES_USER=" .env; then
              echo "‚úÖ Critical env vars present"
            else
              echo "‚ùå Missing critical env vars in .env file!"
              cat .env
              exit 1
            fi

            echo "üê≥ Docker login & pull image"
            # tr√°nh credsStore=pass ‚Üí d√πng c·∫•u h√¨nh t·∫°m
            export DOCKER_CONFIG="$(mktemp -d)"
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

            echo "üß© IMAGE_NAME=$IMAGE_NAME"
            echo "üß© IMAGE_SHA=$IMAGE_SHA"
            
            max_attempts=30; attempt=1
            until docker manifest inspect "$IMAGE_SHA" >/dev/null 2>&1; do
              [ $attempt -ge $max_attempts ] && { echo "‚ùå Ch∆∞a c√≥ $IMAGE_SHA"; exit 1; }
              echo "‚è≥ [$attempt/$max_attempts] waiting registry‚Ä¶"; attempt=$((attempt+1)); sleep 5
            done
            
            docker pull "$IMAGE_SHA"

            # ƒë·∫£m b·∫£o project name ·ªïn ƒë·ªãnh
            export COMPOSE_PROJECT_NAME=btl_oop
            export IMAGE_SHA

            echo "üõë Stop existing containers (if any)"
            docker compose -f docker-compose.prod.yml down || true

            echo "üóÑÔ∏è  Start database dependencies first (postgres, redis, qdrant)"
            docker compose -f docker-compose.prod.yml --env-file .env up -d postgres redis qdrant

            echo "‚è≥ Wait for postgres to be healthy..."
            timeout=60
            elapsed=0
            until docker compose -f docker-compose.prod.yml exec postgres pg_isready -U "${POSTGRES_USER}" > /dev/null 2>&1; do
              if [ $elapsed -ge $timeout ]; then
                echo "‚ùå Postgres failed to become healthy in ${timeout}s"
                exit 1
              fi
              echo "Waiting for postgres... (${elapsed}s/${timeout}s)"
              sleep 5
              elapsed=$((elapsed + 5))
            done
            echo "‚úÖ Postgres is ready!"

            echo "üîÑ Run Alembic migrations"
            docker compose -f docker-compose.prod.yml --env-file .env run --rm \
              fastapi uv run alembic upgrade head

            echo "üöÄ Bring up FastAPI application"
            docker compose -f docker-compose.prod.yml --env-file .env up -d fastapi

            echo "‚è≥ Wait for fastapi to start..."
            sleep 10

            echo "üìã Check fastapi container status:"
            docker compose -f docker-compose.prod.yml ps fastapi

            # Check if fastapi container is running
            if docker compose -f docker-compose.prod.yml ps fastapi | grep -q "Up"; then
              echo "‚úÖ FastAPI container is running"
            else
              echo "‚ùå FastAPI container is NOT running! Showing logs:"
              docker compose -f docker-compose.prod.yml logs --tail=100 fastapi
              exit 1
            fi

            echo "üõ†Ô∏è  Bring up worker"
            docker compose -f docker-compose.prod.yml --env-file .env up -d worker_send_mail

            echo "üìã All running containers:"
            docker compose -f docker-compose.prod.yml ps

#            echo "üßπ Cleanup"
#            docker image prune -f

      - name: Health check
        run: |
          echo "Waiting for application to start..."
          sleep 20
          code=$(curl -s -o /dev/null -w "%{http_code}" "http://${{ secrets.SSH_HOST }}:8000/health" || echo "000")
          echo "HTTP $code"
          [ "$code" = "200" ] && echo "‚úÖ Healthy" || echo "‚ö†Ô∏è Not healthy"

      - name: Notify deployment status
        if: always()
        run: |
          echo "Deployment: ${{ job.status }}"
