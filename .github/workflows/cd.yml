name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types: [completed]
    branches: [main]
  workflow_dispatch:

env:
  IMAGE_NAME: adc300/btl_oop   # repo image tr√™n Docker Hub c·ªßa b·∫°n

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Compute image tags (method #1)
        run: |
          CI_SHA="${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}"
          echo "IMAGE_LATEST=${{ env.IMAGE_NAME }}:latest" >> $GITHUB_ENV
          echo "IMAGE_SHA=${{ env.IMAGE_NAME }}:sha-${CI_SHA}" >> $GITHUB_ENV
          echo "Computed:"
          echo "  IMAGE_LATEST=$IMAGE_LATEST"
          echo "  IMAGE_SHA=$IMAGE_SHA"

      - name: Upload compose to server
        uses: appleboy/scp-action@v1
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: "./docker-compose.prod.yml"   # ch·ªânh path n·∫øu file n·∫±m ·ªü backend/
          target: "${{ secrets.DEPLOY_PATH }}/"

      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          # Image vars t√≠nh ·ªü b∆∞·ªõc tr∆∞·ªõc
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_SHA:  ${{ env.IMAGE_SHA }}

          # App vars
          DEBUG: ${{ secrets.DEBUG || 'False' }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}

          # Database
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_SERVER: ${{ secrets.POSTGRES_SERVER || 'postgres' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}

          # Redis
          REDIS_URL:  ${{ secrets.REDIS_URL  || 'redis://redis:6379' }}
          REDIS_HOST: ${{ secrets.REDIS_HOST || 'redis' }}
          REDIS_PORT: ${{ secrets.REDIS_PORT || '6379' }}
          REDIS_DB:   ${{ secrets.REDIS_DB   || '0' }}

          # Qdrant
          QDRANT_URL: ${{ secrets.QDRANT_URL || 'http://qdrant:6333' }}

          # Security / JWT
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          ALGORITHM:  ${{ secrets.ALGORITHM || 'HS256' }}
          ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES || '30' }}

          # Email / SMTP
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          SMTP_TLS: ${{ secrets.SMTP_TLS }}
          EMAILS_FROM_EMAIL: ${{ secrets.EMAILS_FROM_EMAIL }}
          EMAILS_FROM_NAME: ${{ secrets.EMAILS_FROM_NAME }}

          # Sentry
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}

          # ARQ Worker
          ARQ_QUEUE_NAME: ${{ secrets.ARQ_QUEUE_NAME || 'arq:queue' }}
          ARQ_MAX_JOBS:   ${{ secrets.ARQ_MAX_JOBS   || '10' }}
          ARQ_JOB_TIMEOUT: ${{ secrets.ARQ_JOB_TIMEOUT || '300' }}

          # Superuser
          FIRST_SUPERUSER:          ${{ secrets.FIRST_SUPERUSER }}
          FIRST_SUPERUSER_PASSWORD: ${{ secrets.FIRST_SUPERUSER_PASSWORD }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT != '' && secrets.SSH_PORT || '22' }}
          # Truy·ªÅn c√°c env n√†y sang phi√™n SSH (ƒë·ªÉ script nh√¨n th·∫•y)
          envs: IMAGE_NAME,IMAGE_SHA,DEBUG,FRONTEND_URL,POSTGRES_USER,POSTGRES_PASSWORD,POSTGRES_SERVER,POSTGRES_DB,REDIS_URL,REDIS_HOST,REDIS_PORT,REDIS_DB,QDRANT_URL,SECRET_KEY,ALGORITHM,ACCESS_TOKEN_EXPIRE_MINUTES,SMTP_HOST,SMTP_PORT,SMTP_USER,SMTP_PASSWORD,SMTP_FROM,SMTP_TLS,EMAILS_FROM_EMAIL,EMAILS_FROM_NAME,SENTRY_DSN,ARQ_QUEUE_NAME,ARQ_MAX_JOBS,ARQ_JOB_TIMEOUT,FIRST_SUPERUSER,FIRST_SUPERUSER_PASSWORD
          script: |
            set -euo pipefail

            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            mkdir -p "$DEPLOY_PATH"
            cd "$DEPLOY_PATH"

            # N·∫øu server c·∫ßn sudo cho Docker CE, b·∫≠t 3 d√≤ng n√†y v√† prefix 'sudo -E' cho m·ªçi l·ªánh docker:
            # alias docker='sudo -E docker'
            # alias compose='sudo -E docker compose'
            # export DOCKER_HOST=unix:///var/run/docker.sock

            echo "üîê Write .env (chmod 600)"
            cat > .env <<'EOF'
            DEBUG=${DEBUG}
            FRONTEND_URL=${FRONTEND_URL}

            POSTGRES_USER=${POSTGRES_USER}
            POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            POSTGRES_SERVER=${POSTGRES_SERVER}
            POSTGRES_DB=${POSTGRES_DB}

            REDIS_URL=${REDIS_URL}
            REDIS_HOST=${REDIS_HOST}
            REDIS_PORT=${REDIS_PORT}
            REDIS_DB=${REDIS_DB}

            QDRANT_URL=${QDRANT_URL}

            SECRET_KEY=${SECRET_KEY}
            ALGORITHM=${ALGORITHM}
            ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}

            SMTP_HOST=${SMTP_HOST}
            SMTP_PORT=${SMTP_PORT}
            SMTP_USER=${SMTP_USER}
            SMTP_PASSWORD=${SMTP_PASSWORD}
            SMTP_FROM=${SMTP_FROM}
            SMTP_TLS=${SMTP_TLS}
            EMAILS_FROM_EMAIL=${EMAILS_FROM_EMAIL}
            EMAILS_FROM_NAME=${EMAILS_FROM_NAME}

            SENTRY_DSN=${SENTRY_DSN}

            ARQ_QUEUE_NAME=${ARQ_QUEUE_NAME}
            ARQ_MAX_JOBS=${ARQ_MAX_JOBS}
            ARQ_JOB_TIMEOUT=${ARQ_JOB_TIMEOUT}

            FIRST_SUPERUSER=${FIRST_SUPERUSER}
            FIRST_SUPERUSER_PASSWORD=${FIRST_SUPERUSER_PASSWORD}
            EOF
            chmod 600 .env

            echo "üê≥ Docker login & pull image"
            # tr√°nh credsStore=pass ‚Üí d√πng c·∫•u h√¨nh t·∫°m
            export DOCKER_CONFIG="$(mktemp -d)"
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

            echo "üß© IMAGE_NAME=$IMAGE_NAME"
            echo "üß© IMAGE_SHA=$IMAGE_SHA"
            
            max_attempts=30; attempt=1
            until docker manifest inspect "$IMAGE_SHA" >/dev/null 2>&1; do
              [ $attempt -ge $max_attempts ] && { echo "‚ùå Ch∆∞a c√≥ $IMAGE_SHA"; exit 1; }
              echo "‚è≥ [$attempt/$max_attempts] waiting registry‚Ä¶"; attempt=$((attempt+1)); sleep 5
            done
            
            docker pull "$IMAGE_SHA"

            # ƒë·∫£m b·∫£o project name ·ªïn ƒë·ªãnh
            export COMPOSE_PROJECT_NAME=btl_oop
            export IMAGE_SHA

            echo "üîÑ Alembic migrate (one-off)"
            docker compose -f docker-compose.prod.yml --env-file .env run --rm \
              fastapi uv run alembic upgrade head

            echo "üöÄ Bring up API"
            docker compose -f docker-compose.prod.yml --env-file .env up -d fastapi

            echo "üõ†Ô∏è  Bring up worker (optional)"
            docker compose -f docker-compose.prod.yml --env-file .env up -d worker_send_mail

            echo "üßπ Cleanup"
            docker image prune -f

      - name: Health check
        run: |
          echo "Waiting for application to start..."
          sleep 20
          code=$(curl -s -o /dev/null -w "%{http_code}" "http://${{ secrets.SSH_HOST }}:8000/health" || echo "000")
          echo "HTTP $code"
          [ "$code" = "200" ] && echo "‚úÖ Healthy" || echo "‚ö†Ô∏è Not healthy"

      - name: Notify deployment status
        if: always()
        run: |
          echo "Deployment: ${{ job.status }}"
