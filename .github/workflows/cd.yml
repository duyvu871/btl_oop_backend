name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

env:
  IMAGE_NAME: adc300/btl_oop

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
#      - name: Debug backend files
#        run: |
#          echo "Current workspace:"
#          pwd
#          echo "Backend directory contents:"
#          ls -R ./backend || echo "Backend folder not found!"
#      - name: Debug file tree
#        run: |
#          echo "ðŸ“‚ Current workspace:"
#          pwd
#          ls -R .
      - name: Upload compose to server
        uses: appleboy/scp-action@v1
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: "./docker-compose.prod.yml"
          target: "${{ secrets.DEPLOY_PATH || '~/src/btl_oop_ptit' }}/"
      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          # General
          DEBUG: ${{ secrets.DEBUG || 'False' }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          # Database
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_SERVER: ${{ secrets.POSTGRES_SERVER || 'postgres' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          # Redis
          REDIS_URL: ${{ secrets.REDIS_URL || 'redis://redis:6379' }}
          REDIS_HOST: ${{ secrets.REDIS_HOST || 'redis' }}
          REDIS_PORT: ${{ secrets.REDIS_PORT || '6379' }}
          REDIS_DB: ${{ secrets.REDIS_DB || '0' }}
          # Qdrant
          QDRANT_URL: ${{ secrets.QDRANT_URL || 'http://qdrant:6333' }}
          # Security / JWT
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          ALGORITHM: ${{ secrets.ALGORITHM || 'HS256' }}
          ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES || '30' }}
          # Email / SMTP
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          SMTP_TLS: ${{ secrets.SMTP_TLS }}
          EMAILS_FROM_EMAIL: ${{ secrets.EMAILS_FROM_EMAIL }}
          EMAILS_FROM_NAME: ${{ secrets.EMAILS_FROM_NAME }}
          # Sentry
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          # ARQ Worker
          ARQ_QUEUE_NAME: ${{ secrets.ARQ_QUEUE_NAME || 'arq:queue' }}
          ARQ_MAX_JOBS: ${{ secrets.ARQ_MAX_JOBS || '10' }}
          ARQ_JOB_TIMEOUT: ${{ secrets.ARQ_JOB_TIMEOUT || '300' }}
          # Superuser
          FIRST_SUPERUSER: ${{ secrets.FIRST_SUPERUSER }}
          FIRST_SUPERUSER_PASSWORD: ${{ secrets.FIRST_SUPERUSER_PASSWORD }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT != '' && secrets.SSH_PORT || '22' }}
          envs: DEBUG,FRONTEND_URL,POSTGRES_USER,POSTGRES_PASSWORD,POSTGRES_SERVER,POSTGRES_DB,REDIS_URL,REDIS_HOST,REDIS_PORT,REDIS_DB,QDRANT_URL,SECRET_KEY,ALGORITHM,ACCESS_TOKEN_EXPIRE_MINUTES,SMTP_HOST,SMTP_PORT,SMTP_USER,SMTP_PASSWORD,SMTP_FROM,SMTP_TLS,EMAILS_FROM_EMAIL,EMAILS_FROM_NAME,SENTRY_DSN,ARQ_QUEUE_NAME,ARQ_MAX_JOBS,ARQ_JOB_TIMEOUT,FIRST_SUPERUSER,FIRST_SUPERUSER_PASSWORD
          script: |
            set -euo pipefail
            
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH || '/home/' }}${{ secrets.SSH_USERNAME }}/src/btl_oop_ptit"
            mkdir -p "$DEPLOY_PATH"
            cd "$DEPLOY_PATH"
            
            echo "ðŸ” Write .env (chmod 600)"
            cat > .env <<'EOF'
            # ---- Runtime env (KHÃ”NG commit file nÃ y) ----
            DEBUG=${DEBUG}
            FRONTEND_URL=${FRONTEND_URL}
            
            # Postgres database
            POSTGRES_USER=${POSTGRES_USER}
            POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            POSTGRES_SERVER=${POSTGRES_SERVER}
            POSTGRES_DB=${POSTGRES_DB}
            
            # Redis
            REDIS_URL=${REDIS_URL}
            REDIS_HOST=${REDIS_HOST}
            REDIS_PORT=${REDIS_PORT}
            REDIS_DB=${REDIS_DB}
            
            # Qdrant
            QDRANT_URL=${QDRANT_URL}
            
            # JWT
            SECRET_KEY=${SECRET_KEY}
            ALGORITHM=${ALGORITHM}
            ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}
            
            # SMTP / Email
            SMTP_HOST=${SMTP_HOST}
            SMTP_PORT=${SMTP_PORT}
            SMTP_USER=${SMTP_USER}
            SMTP_PASSWORD=${SMTP_PASSWORD}
            SMTP_FROM=${SMTP_FROM}
            SMTP_TLS=${SMTP_TLS}
            EMAILS_FROM_EMAIL=${EMAILS_FROM_EMAIL}
            EMAILS_FROM_NAME=${EMAILS_FROM_NAME}
            
            # Sentry
            SENTRY_DSN=${SENTRY_DSN}
            
            # ARQ Worker
            ARQ_QUEUE_NAME=${ARQ_QUEUE_NAME}
            ARQ_MAX_JOBS=${ARQ_MAX_JOBS}
            ARQ_JOB_TIMEOUT=${ARQ_JOB_TIMEOUT}
            
            # Superuser
            FIRST_SUPERUSER=${FIRST_SUPERUSER}
            FIRST_SUPERUSER_PASSWORD=${FIRST_SUPERUSER_PASSWORD}
            EOF
            chmod 600 .env
            
            echo "ðŸ³ Docker login & pull image"
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
            docker pull "${{ needs.build_and_push.outputs.image_sha }}"
            
            # Gá»£i Ã½: trong docker-compose.prod.yml Ä‘áº·t image = IMAGE_SHA Ä‘á»ƒ up Ä‘Ãºng tag
            # hoáº·c dÃ¹ng env var Ä‘á»ƒ override khi up:
            # COMPOSE_PROJECT_NAME giÃºp tÃªn container á»•n Ä‘á»‹nh giá»¯a cÃ¡c deploy
            export COMPOSE_PROJECT_NAME=btl_oop
            export IMAGE_SHA="${{ needs.build_and_push.outputs.image_sha }}"
            
            # 1) Migrate DB báº±ng one-off container (Ã­t downtime, cÃ¹ng image má»›i)
            echo "ðŸ”„ Alembic migrate"
            docker compose -f docker-compose.prod.yml --env-file .env run --rm \
            -e DATABASE_URL -e SECRET_KEY -e ALGORITHM \
            fastapi uv run alembic upgrade head
            
            # 2) Khá»Ÿi Ä‘á»™ng/refresh API vá»›i image má»›i
            echo "ðŸš€ Bring up API"
            docker compose -f docker-compose.prod.yml --env-file .env up -d fastapi
            
            # 3) (Optional) restart phá»¥ trá»£ khÃ¡c (worker, nginx...) náº¿u cÃ³
            docker compose -f docker-compose.prod.yml up -d worker_send_mail
            
            # 4) Cleanup image treo
            docker image prune -f

      - name: Health check
        run: |
          echo "Waiting for application to start..."
          sleep 30
          
          # Check if the application is responding
          response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SSH_HOST }}:8000/health || echo "000")
          
          if [ "$response" = "200" ]; then
            echo "âœ… Application is healthy!"
          else
            echo "âš ï¸  Health check returned: $response"
            echo "Please check the application manually"
          fi

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "ðŸš€ Deployment successful!"
          else
            echo "âŒ Deployment failed!"
          fi

#  notify:
#    runs-on: ubuntu-latest
#    needs:
#      - deploy
#    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
#    permissions:
#      actions: read
#      contents: read
#    steps:
#      - uses: actions/checkout@v5
#      - name: Send webhook
#        uses: ./.github/actions/notify
#        with:
#          webhook_url: ${{ secrets.WEBHOOK_URL }}
#          webhook_secret: ${{ secrets.WEBHOOK_SECRET }}